/*
 * SPDX-FileCopyrightText: 2023-2023 Istituto Italiano di Tecnologia (IIT)
 * SPDX-License-Identifier: LGPL-2.1-or-later
 */


// Generated by yarpDeviceParamParserGenerator (1.0)
// This is an automatically generated file. Please do not edit it.
// It will be re-generated if the cmake flag ALLOW_DEVICE_PARAM_PARSER_GERNERATION is ON.

// Generated on: Sun Apr 20 14:33:40 2025


#include "EmulatedControlBoard_ParamsParser.h"
#include <yarp/os/LogStream.h>
#include <yarp/os/Value.h>

namespace {
    YARP_LOG_COMPONENT(EmulatedControlBoardParamsCOMPONENT, "yarp.device.EmulatedControlBoard")
}


EmulatedControlBoard_ParamsParser::EmulatedControlBoard_ParamsParser()
{
}


std::vector<std::string> EmulatedControlBoard_ParamsParser::getListOfParams() const
{
    std::vector<std::string> params;
    params.push_back("axes");
    params.push_back("jmcMs");
    params.push_back("mode");
    params.push_back("genInitPos");
    params.push_back("genJointTol");
    params.push_back("genMaxLimit");
    params.push_back("genMinLimit");
    params.push_back("genRefSpeed");
    params.push_back("genEncRawExposed");
    params.push_back("genVelRawExposed");
    params.push_back("initPoss");
    params.push_back("jointTols");
    params.push_back("maxLimits");
    params.push_back("minLimits");
    params.push_back("refSpeeds");
    params.push_back("encRawExposeds");
    params.push_back("velRawExposeds");
    return params;
}


bool      EmulatedControlBoard_ParamsParser::parseParams(const yarp::os::Searchable & config)
{
    //Check for --help option
    if (config.check("help"))
    {
        yCInfo(EmulatedControlBoardParamsCOMPONENT) << getDocumentationOfDeviceParams();
    }

    std::string config_string = config.toString();
    yarp::os::Property prop_check(config_string.c_str());
    //Parser of parameter axes
    {
        if (config.check("axes"))
        {
            m_axes = config.find("axes").asInt64();
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'axes' using value:" << m_axes;
        }
        else
        {
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'axes' using DEFAULT value:" << m_axes;
        }
        prop_check.unput("axes");
    }

    //Parser of parameter jmcMs
    {
        if (config.check("jmcMs"))
        {
            m_jmcMs = config.find("jmcMs").asInt64();
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'jmcMs' using value:" << m_jmcMs;
        }
        else
        {
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'jmcMs' using DEFAULT value:" << m_jmcMs;
        }
        prop_check.unput("jmcMs");
    }

    //Parser of parameter mode
    {
        if (config.check("mode"))
        {
            m_mode = config.find("mode").asString();
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'mode' using value:" << m_mode;
        }
        else
        {
            yCError(EmulatedControlBoardParamsCOMPONENT) << "Mandatory parameter 'mode' not found!";
            yCError(EmulatedControlBoardParamsCOMPONENT) << "Description of the parameter: control mode";
            return false;
        }
        prop_check.unput("mode");
    }

    //Parser of parameter genInitPos
    {
        if (config.check("genInitPos"))
        {
            m_genInitPos = config.find("genInitPos").asFloat64();
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'genInitPos' using value:" << m_genInitPos;
        }
        else
        {
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'genInitPos' using DEFAULT value:" << m_genInitPos;
        }
        prop_check.unput("genInitPos");
    }

    //Parser of parameter genJointTol
    {
        if (config.check("genJointTol"))
        {
            m_genJointTol = config.find("genJointTol").asFloat64();
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'genJointTol' using value:" << m_genJointTol;
        }
        else
        {
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'genJointTol' using DEFAULT value:" << m_genJointTol;
        }
        prop_check.unput("genJointTol");
    }

    //Parser of parameter genMaxLimit
    {
        if (config.check("genMaxLimit"))
        {
            m_genMaxLimit = config.find("genMaxLimit").asFloat64();
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'genMaxLimit' using value:" << m_genMaxLimit;
        }
        else
        {
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'genMaxLimit' using DEFAULT value:" << m_genMaxLimit;
        }
        prop_check.unput("genMaxLimit");
    }

    //Parser of parameter genMinLimit
    {
        if (config.check("genMinLimit"))
        {
            m_genMinLimit = config.find("genMinLimit").asFloat64();
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'genMinLimit' using value:" << m_genMinLimit;
        }
        else
        {
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'genMinLimit' using DEFAULT value:" << m_genMinLimit;
        }
        prop_check.unput("genMinLimit");
    }

    //Parser of parameter genRefSpeed
    {
        if (config.check("genRefSpeed"))
        {
            m_genRefSpeed = config.find("genRefSpeed").asFloat64();
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'genRefSpeed' using value:" << m_genRefSpeed;
        }
        else
        {
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'genRefSpeed' using DEFAULT value:" << m_genRefSpeed;
        }
        prop_check.unput("genRefSpeed");
    }

    //Parser of parameter genEncRawExposed
    {
        if (config.check("genEncRawExposed"))
        {
            m_genEncRawExposed = config.find("genEncRawExposed").asFloat64();
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'genEncRawExposed' using value:" << m_genEncRawExposed;
        }
        else
        {
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'genEncRawExposed' using DEFAULT value:" << m_genEncRawExposed;
        }
        prop_check.unput("genEncRawExposed");
    }

    //Parser of parameter genVelRawExposed
    {
        if (config.check("genVelRawExposed"))
        {
            m_genVelRawExposed = config.find("genVelRawExposed").asFloat64();
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'genVelRawExposed' using value:" << m_genVelRawExposed;
        }
        else
        {
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'genVelRawExposed' using DEFAULT value:" << m_genVelRawExposed;
        }
        prop_check.unput("genVelRawExposed");
    }

    //Parser of parameter initPoss
    {
        if (config.check("initPoss"))
        {
            {
                m_initPoss.clear();
                yarp::os::Bottle* tempBot = config.find("initPoss").asList();
                if (tempBot)
                {
                    std::string tempBots = tempBot->toString();
                    for (size_t i=0; i<tempBot->size(); i++)
                    {
                        m_initPoss.push_back(tempBot->get(i).asFloat64());
                    }
                }
                else
                {
                     yCError(EmulatedControlBoardParamsCOMPONENT) <<"parameter 'initPoss' is not a properly formatted bottle";
                }
            }
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'initPoss' using value:" << m_initPoss;
        }
        else
        {
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'initPoss' using DEFAULT value:" << m_initPoss;
        }
        prop_check.unput("initPoss");
    }

    //Parser of parameter jointTols
    {
        if (config.check("jointTols"))
        {
            {
                m_jointTols.clear();
                yarp::os::Bottle* tempBot = config.find("jointTols").asList();
                if (tempBot)
                {
                    std::string tempBots = tempBot->toString();
                    for (size_t i=0; i<tempBot->size(); i++)
                    {
                        m_jointTols.push_back(tempBot->get(i).asFloat64());
                    }
                }
                else
                {
                     yCError(EmulatedControlBoardParamsCOMPONENT) <<"parameter 'jointTols' is not a properly formatted bottle";
                }
            }
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'jointTols' using value:" << m_jointTols;
        }
        else
        {
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'jointTols' using DEFAULT value:" << m_jointTols;
        }
        prop_check.unput("jointTols");
    }

    //Parser of parameter maxLimits
    {
        if (config.check("maxLimits"))
        {
            {
                m_maxLimits.clear();
                yarp::os::Bottle* tempBot = config.find("maxLimits").asList();
                if (tempBot)
                {
                    std::string tempBots = tempBot->toString();
                    for (size_t i=0; i<tempBot->size(); i++)
                    {
                        m_maxLimits.push_back(tempBot->get(i).asFloat64());
                    }
                }
                else
                {
                     yCError(EmulatedControlBoardParamsCOMPONENT) <<"parameter 'maxLimits' is not a properly formatted bottle";
                }
            }
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'maxLimits' using value:" << m_maxLimits;
        }
        else
        {
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'maxLimits' using DEFAULT value:" << m_maxLimits;
        }
        prop_check.unput("maxLimits");
    }

    //Parser of parameter minLimits
    {
        if (config.check("minLimits"))
        {
            {
                m_minLimits.clear();
                yarp::os::Bottle* tempBot = config.find("minLimits").asList();
                if (tempBot)
                {
                    std::string tempBots = tempBot->toString();
                    for (size_t i=0; i<tempBot->size(); i++)
                    {
                        m_minLimits.push_back(tempBot->get(i).asFloat64());
                    }
                }
                else
                {
                     yCError(EmulatedControlBoardParamsCOMPONENT) <<"parameter 'minLimits' is not a properly formatted bottle";
                }
            }
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'minLimits' using value:" << m_minLimits;
        }
        else
        {
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'minLimits' using DEFAULT value:" << m_minLimits;
        }
        prop_check.unput("minLimits");
    }

    //Parser of parameter refSpeeds
    {
        if (config.check("refSpeeds"))
        {
            {
                m_refSpeeds.clear();
                yarp::os::Bottle* tempBot = config.find("refSpeeds").asList();
                if (tempBot)
                {
                    std::string tempBots = tempBot->toString();
                    for (size_t i=0; i<tempBot->size(); i++)
                    {
                        m_refSpeeds.push_back(tempBot->get(i).asFloat64());
                    }
                }
                else
                {
                     yCError(EmulatedControlBoardParamsCOMPONENT) <<"parameter 'refSpeeds' is not a properly formatted bottle";
                }
            }
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'refSpeeds' using value:" << m_refSpeeds;
        }
        else
        {
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'refSpeeds' using DEFAULT value:" << m_refSpeeds;
        }
        prop_check.unput("refSpeeds");
    }

    //Parser of parameter encRawExposeds
    {
        if (config.check("encRawExposeds"))
        {
            {
                m_encRawExposeds.clear();
                yarp::os::Bottle* tempBot = config.find("encRawExposeds").asList();
                if (tempBot)
                {
                    std::string tempBots = tempBot->toString();
                    for (size_t i=0; i<tempBot->size(); i++)
                    {
                        m_encRawExposeds.push_back(tempBot->get(i).asFloat64());
                    }
                }
                else
                {
                     yCError(EmulatedControlBoardParamsCOMPONENT) <<"parameter 'encRawExposeds' is not a properly formatted bottle";
                }
            }
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'encRawExposeds' using value:" << m_encRawExposeds;
        }
        else
        {
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'encRawExposeds' using DEFAULT value:" << m_encRawExposeds;
        }
        prop_check.unput("encRawExposeds");
    }

    //Parser of parameter velRawExposeds
    {
        if (config.check("velRawExposeds"))
        {
            {
                m_velRawExposeds.clear();
                yarp::os::Bottle* tempBot = config.find("velRawExposeds").asList();
                if (tempBot)
                {
                    std::string tempBots = tempBot->toString();
                    for (size_t i=0; i<tempBot->size(); i++)
                    {
                        m_velRawExposeds.push_back(tempBot->get(i).asFloat64());
                    }
                }
                else
                {
                     yCError(EmulatedControlBoardParamsCOMPONENT) <<"parameter 'velRawExposeds' is not a properly formatted bottle";
                }
            }
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'velRawExposeds' using value:" << m_velRawExposeds;
        }
        else
        {
            yCInfo(EmulatedControlBoardParamsCOMPONENT) << "Parameter 'velRawExposeds' using DEFAULT value:" << m_velRawExposeds;
        }
        prop_check.unput("velRawExposeds");
    }

    /*
    //This code check if the user set some parameter which are not check by the parser
    //If the parser is set in strict mode, this will generate an error
    if (prop_check.size() > 0)
    {
        bool extra_params_found = false;
        for (auto it=prop_check.begin(); it!=prop_check.end(); it++)
        {
            if (m_parser_is_strict)
            {
                yCError(EmulatedControlBoardParamsCOMPONENT) << "User asking for parameter: "<<it->name <<" which is unknown to this parser!";
                extra_params_found = true;
            }
            else
            {
                yCWarning(EmulatedControlBoardParamsCOMPONENT) << "User asking for parameter: "<< it->name <<" which is unknown to this parser!";
            }
        }

       if (m_parser_is_strict && extra_params_found)
       {
           return false;
       }
    }
    */
    return true;
}


std::string      EmulatedControlBoard_ParamsParser::getDocumentationOfDeviceParams() const
{
    std::string doc;
    doc = doc + std::string("\n=============================================\n");
    doc = doc + std::string("This is the help for device: EmulatedControlBoard\n");
    doc = doc + std::string("\n");
    doc = doc + std::string("This is the list of the parameters accepted by the device:\n");
    doc = doc + std::string("'axes': number of axes to control\n");
    doc = doc + std::string("'jmcMs': period of JMC periodic thread\n");
    doc = doc + std::string("'mode': control mode\n");
    doc = doc + std::string("'genInitPos': general initialization positions\n");
    doc = doc + std::string("'genJointTol': general joint tolerances\n");
    doc = doc + std::string("'genMaxLimit': general max limits\n");
    doc = doc + std::string("'genMinLimit': general min limits\n");
    doc = doc + std::string("'genRefSpeed': general ref speed\n");
    doc = doc + std::string("'genEncRawExposed': general EncRawExposed\n");
    doc = doc + std::string("'genVelRawExposed': general VelRawExposed\n");
    doc = doc + std::string("'initPoss': individual initialization positions\n");
    doc = doc + std::string("'jointTols': individual joint tolerances\n");
    doc = doc + std::string("'maxLimits': individual max limits\n");
    doc = doc + std::string("'minLimits': individual min limits\n");
    doc = doc + std::string("'refSpeeds': individual ref speeds\n");
    doc = doc + std::string("'encRawExposeds': individual EncRawExposed\n");
    doc = doc + std::string("'velRawExposeds': individual VelRawExposed\n");
    doc = doc + std::string("\n");
    doc = doc + std::string("Here are some examples of invocation command with yarpdev, with all params:\n");
    doc = doc + " yarpdev --device EmulatedControlBoard --axes 5 --jmcMs 20 --mode <mandatory_value> --genInitPos 0.0 --genJointTol 0.25 --genMaxLimit 180.0 --genMinLimit -180.0 --genRefSpeed 7.5 --genEncRawExposed 0.0174532925199433 --genVelRawExposed 0.0174532925199433 --initPoss <optional_value> --jointTols <optional_value> --maxLimits <optional_value> --minLimits <optional_value> --refSpeeds <optional_value> --encRawExposeds <optional_value> --velRawExposeds <optional_value>\n";
    doc = doc + std::string("Using only mandatory params:\n");
    doc = doc + " yarpdev --device EmulatedControlBoard --mode <mandatory_value>\n";
    doc = doc + std::string("=============================================\n\n");    return doc;
}
